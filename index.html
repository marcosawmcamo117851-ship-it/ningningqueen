<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å®å®å¤§ç‹ - Merry Christmas</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'ZCOOL KuaiLe', sans-serif; }
        #canvas-wrapper { position: relative; background: #000; height: 100vh; width: 100vw; }
        #canvas-container { width: 100%; height: 100%; display: block; }
        
        #video-container {
            position: absolute; top: 20px; right: 20px; width: 120px; height: 90px; z-index: 2;
            border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); background: rgba(0,0,0,0.5); opacity: 0.8;
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        
        #title-layer {
            position: absolute; top: 5%; left: 0; width: 100%; display: flex; justify-content: center;
            z-index: 4; pointer-events: none; text-align: center;
        }
        h1 {
            font-family: 'ZCOOL KuaiLe', sans-serif; font-weight: 400; letter-spacing: 2px; font-size: 2.5rem; margin: 0;
            background: linear-gradient(to bottom, #fff 30%, #ffd700 90%); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 3; pointer-events: none; color: #fff; }
        .instructions {
            font-size: 0.9rem; color: #ccc; line-height: 1.6;
            background: rgba(0, 0, 0, 0.6); padding: 12px; border-radius: 8px;
            border-left: 3px solid #ffd700;
        }
        .highlight { color: #ffd700; font-weight: bold; }
        #status-text { margin-bottom: 8px; font-size: 1.2rem; color: #fff; font-weight: bold; }
        
        #fullscreen-btn {
            position: absolute; top: 20px; right: 150px; z-index: 20;
            background: rgba(0,0,0,0.3); color: #ffd700; border: 1px solid #ffd700;
            width: 36px; height: 36px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 1.1rem;
        }
        
        #debug-console {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 80px;
            background: rgba(50, 0, 0, 0.8); color: #ffaaaa; 
            font-family: monospace; font-size: 12px; padding: 10px;
            overflow-y: scroll; z-index: 9999; display: none; pointer-events: none;
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>
    <audio id="bgm" loop><source src="music.mp3" type="audio/mp3"></audio>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
        <div id="title-layer"><h1>å®å®å¤§ç‹ Merry Christmas</h1></div>
        
        <div id="video-container">
            <video id="input-video" autoplay playsinline muted></video>
            <canvas id="skeleton-canvas"></canvas>
        </div>
        
        <button id="fullscreen-btn" onclick="toggleUI()">â›¶</button>

        <div id="ui-layer">
            <div id="status-text">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>
            <div class="instructions">
                â€¢ <span class="highlight">æ¡æ‹³/è‡ªç„¶</span> : åœ£è¯æ ‘<br/>
                â€¢ <span class="highlight">å¼ å¼€æ‰‹</span> : æ˜Ÿäº‘æ•£å¼€ (å·¦å³æ‹¨åŠ¨)<br/>
                â€¢ <span class="highlight">æ¯”è€¶(âœŒï¸)</span> : å˜æˆæ–‡å­—<br/>
                â€¢ <span class="highlight">æåˆ(ğŸ‘Œ)</span> : æŠ“å–ç…§ç‰‡ (èƒŒæ™¯å®šæ ¼)
            </div>
        </div>
        <div id="debug-console"></div>
    </div>

    <canvas id="textCanvas" width="1024" height="256" style="display:none;"></canvas>

    <script type="module">
        window.onerror = function(msg, url, line) {
            const div = document.getElementById('debug-console');
            div.style.display = 'block';
            div.innerHTML += `ERR: ${msg} (L${line})<br>`;
        };

        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        const myPhotos = ['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg', '9.jpg', '10.jpg', '11.jpg', '12.jpg', '13.jpg', '14.jpg', '15.jpg', '16.jpg', '17.jpg', '18.jpg', '19.jpg', '20.jpg', '21.jpg', '22.jpg', '23.jpg', '24.jpg', '25.jpg', '26.jpg', '27.jpg'];

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const CONFIG = {
            goldCount: 200, silverCount: 200, gemCount: 150, emeraldCount: 150,
            dustCount: 500, treeHeight: 75, maxRadius: 30
        };

        const STATE = { TREE: 'tree', SCATTER: 'scatter', ZOOM: 'zoom', TEXT: 'text' };
        let currentState = STATE.TREE;
        let backgroundState = STATE.TREE; // è®°å¿†èƒŒæ™¯çŠ¶æ€
        
        let scene, camera, renderer, composer, mainGroup = new THREE.Group();
        let goldMesh, silverMesh, gemMesh, emeraldMesh, dustSystem;
        let photoMeshes = [];
        let zoomTargetIndex = -1;
        let logicData = { gold: [], silver: [], gem: [], emerald: [], dust: [], textTargets: [] };
        const dummy = new THREE.Object3D();
        let time = 0;
        
        let handPos = { x: 0, y: 0 };
        let lastHandPos = { x: 0, y: 0 };
        let isHandPresent = false;
        let rotationVelocity = { x: 0, y: 0 };
        let aiReady = false;

        window.toggleUI = function() { document.getElementById('canvas-wrapper').classList.toggle('hide-ui'); };

        function initMusic() {
            const audio = document.getElementById('bgm');
            const playAudio = () => { if(audio.paused) audio.play().catch(e => {}); };
            document.body.addEventListener('click', playAudio, { once: true });
            document.body.addEventListener('touchstart', playAudio, { once: true });
        }

        function generateTextTargets(font = 'Arial') {
            try {
                const canvas = document.getElementById('textCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `bold 130px "${font}", "SimHei", sans-serif`;
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('å®å®å¤§ç‹åœ£è¯å¿«ä¹', canvas.width / 2, canvas.height / 2);
                const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                logicData.textTargets = [];
                const step = 5; 
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        if (data[(y * canvas.width + x) * 4 + 3] > 128) {
                            logicData.textTargets.push(new THREE.Vector3((x - canvas.width / 2) * 0.12, -(y - canvas.height / 2) * 0.12 + 5, 0));
                        }
                    }
                }
                logicData.textTargets.sort(() => Math.random() - 0.5);
            } catch(e) {}
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            const wrapper = document.getElementById('canvas-wrapper');
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x020202); 
            
            updateDimensions();
            camera = new THREE.PerspectiveCamera(50, wrapper.clientWidth / wrapper.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 110);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);
            
            scene.environment = new THREE.PMREMGenerator(renderer).fromScene(new RoomEnvironment(), 0.04).texture;
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const spotLight = new THREE.SpotLight(0xffddaa, 80); spotLight.position.set(30, 60, 50); spotLight.angle = Math.PI/4; spotLight.penumbra=1; scene.add(spotLight);
            scene.add(new THREE.PointLight(0xaaddff, 40, 100).translateY(-20).translateX(-30).translateZ(30));
            
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(wrapper.clientWidth, wrapper.clientHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.3; bloomPass.strength = 0.5; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            createMaterialsAndMeshes(); createDust(); createStarField(); loadBuiltInPhotos();
            scene.add(mainGroup);

            window.addEventListener('resize', onWindowResize);
            initMusic();
            generateTextTargets('ZCOOL KuaiLe'); 
            document.fonts.load('130px "ZCOOL KuaiLe"').then(() => generateTextTargets('ZCOOL KuaiLe')).catch(()=>{});

            animate();
            document.getElementById('status-text').innerText = "ç”»é¢å°±ç»ªï¼Œæ­£åœ¨è¿æ¥æ‘„åƒå¤´...";
            setupMediaPipe();
        }

        function updateDimensions() {
            const targetAspect = 4 / 3; const windowAspect = window.innerWidth / window.innerHeight;
            let width, height;
            if (windowAspect > targetAspect) { height = window.innerHeight; width = height * targetAspect; } 
            else { width = window.innerWidth; height = width / targetAspect; }
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = width + 'px'; wrapper.style.height = height + 'px';
            return { width, height };
        }

        function createMaterialsAndMeshes() {
            const goldMat = new THREE.MeshPhysicalMaterial({ color: 0xffaa00, metalness: 1.0, roughness: 0.15, emissive: 0xaa5500, emissiveIntensity: 0.1 });
            const silverMat = new THREE.MeshPhysicalMaterial({ color: 0xeeeeee, metalness: 0.9, roughness: 0.2, emissive: 0x222222, emissiveIntensity: 0.1 });
            const gemMat = new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.1, roughness: 0.0, transmission: 0.5, thickness: 1.0, emissive: 0x440011, emissiveIntensity: 0.3 });
            const emeraldMat = new THREE.MeshPhysicalMaterial({ color: 0x00aa55, metalness: 0.2, roughness: 0.1, transmission: 0.4, thickness: 1.5, emissive: 0x002211, emissiveIntensity: 0.2 });

            goldMesh = createInstancedMesh(new THREE.SphereGeometry(0.7, 8, 8), goldMat, CONFIG.goldCount, logicData.gold);
            silverMesh = createInstancedMesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), silverMat, CONFIG.silverCount, logicData.silver);
            gemMesh = createInstancedMesh(new THREE.OctahedronGeometry(0.8, 0), gemMat, CONFIG.gemCount, logicData.gem);
            emeraldMesh = createInstancedMesh(new THREE.ConeGeometry(0.5, 1.2, 6), emeraldMat, CONFIG.emeraldCount, logicData.emerald);

            const star = new THREE.Mesh(new THREE.OctahedronGeometry(3.0, 0), new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness:0.8, roughness:0, emissive:0xffffee, emissiveIntensity:1 }));
            star.userData = { treePos: new THREE.Vector3(0, CONFIG.treeHeight/2 + 2, 0), scatterPos: new THREE.Vector3(0, 60, 0) };
            star.position.copy(star.userData.treePos); mainGroup.add(star); logicData.star = star;
        }

        function createInstancedMesh(geo, mat, count, dataArray) {
            const mesh = new THREE.InstancedMesh(geo, mat, count); mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); mainGroup.add(mesh);
            generateLogicData(count, dataArray); return mesh;
        }

        function generateLogicData(count, array) {
            for (let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const normH = (h + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                const rMax = CONFIG.maxRadius * (1 - normH); const r = Math.sqrt(Math.random()) * rMax; const theta = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));
                array.push({
                    treePos: treePos, scatterPos: randomSpherePoint(40 + Math.random()*40), currentPos: treePos.clone(),
                    scale: 0.6 + Math.random() * 0.8, rotSpeed: new THREE.Euler(Math.random()*0.03, Math.random()*0.03, Math.random()*0.03), rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0)
                });
            }
        }

        function randomSpherePoint(r) {
            const u = Math.random(), v = Math.random(); const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }

        function createDust() {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for(let i=0; i<CONFIG.dustCount; i++) {
                const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const r = Math.random() * CONFIG.maxRadius * (1 - (h + CONFIG.treeHeight/2)/CONFIG.treeHeight) + 2; 
                const theta = Math.random() * Math.PI * 2; pos.push(r*Math.cos(theta), h, r*Math.sin(theta));
                logicData.dust.push({ treePos: new THREE.Vector3(r*Math.cos(theta), h, r*Math.sin(theta)), scatterPos: randomSpherePoint(60), currentPos: new THREE.Vector3(r*Math.cos(theta), h, r*Math.sin(theta)) });
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            dustSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffee, size: 0.6, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false }));
            mainGroup.add(dustSystem);
        }
        
        function createStarField() {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for(let i=0; i<800; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color: 0x888888, size: 1.0, transparent: true, opacity: 0.4})));
        }

        let globalParticleIndex = 0;
        function animate() {
            requestAnimationFrame(animate); time += 0.01; globalParticleIndex = 0;
            
            if(goldMesh) updateInstancedMesh(goldMesh, logicData.gold); 
            if(silverMesh) updateInstancedMesh(silverMesh, logicData.silver);
            if(gemMesh) updateInstancedMesh(gemMesh, logicData.gem); 
            if(emeraldMesh) updateInstancedMesh(emeraldMesh, logicData.emerald);
            if(dustSystem) updateDust(); 
            updatePhotos();
            
            if (logicData.star) {
                let target;
                let effectiveState = currentState;
                // === å…³é”®ï¼šZoomæ—¶èƒŒæ™¯çŠ¶æ€ä¿æŒä¸å˜ ===
                if(currentState === STATE.ZOOM) effectiveState = backgroundState;

                if (effectiveState === STATE.TREE) target = logicData.star.userData.treePos;
                else if (effectiveState === STATE.TEXT) target = new THREE.Vector3(0, 20, 0);
                else target = logicData.star.userData.scatterPos;
                
                logicData.star.position.lerp(target, 0.05); logicData.star.rotation.y += 0.01;
            }

            if (currentState === STATE.ZOOM) { 
                // æŠ“å–ç…§ç‰‡æ—¶ï¼ŒèƒŒæ™¯å½»åº•é™æ­¢ï¼Œä¸é‡ç½®ï¼Œä¸æ—‹è½¬
            } else if (currentState === STATE.TEXT) { 
                // æ–‡å­—æ—¶ï¼Œå›æ­£
                rotationVelocity.x = 0; rotationVelocity.y = 0;
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 0.05);
                mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, 0, 0.05);
            } else if (currentState === STATE.SCATTER) {
                if (isHandPresent && aiReady) {
                    const deltaX = handPos.x - lastHandPos.x; 
                    // å·¦å³æ‹¨åŠ¨
                    if (Math.abs(deltaX) > 0.001) rotationVelocity.y += deltaX * 0.15; 
                    lastHandPos.x = handPos.x; lastHandPos.y = handPos.y;
                }
                // === é˜»åŠ›éå¸¸å°ï¼Œæ¥è¿‘æ— é˜»å°¼ ===
                rotationVelocity.y *= 0.98; 
                mainGroup.rotation.y += rotationVelocity.y; 
                // å¼ºåˆ¶Xè½´ä¸è½¬
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 0.1);
            } else if (currentState === STATE.TREE) { 
                mainGroup.rotation.y += 0.003; 
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 0.05);
            }
            if(composer) composer.render();
        }

        function updateInstancedMesh(mesh, dataArray) {
            for (let i = 0; i < dataArray.length; i++) {
                const item = dataArray[i];
                let target;
                
                // === å…³é”®ï¼šZoomæ—¶èƒŒæ™¯çŠ¶æ€ä¿æŒä¸å˜ ===
                let effectiveState = currentState;
                if(currentState === STATE.ZOOM) effectiveState = backgroundState;

                if (effectiveState === STATE.TREE) target = item.treePos;
                else if (effectiveState === STATE.TEXT) {
                    if (globalParticleIndex < logicData.textTargets.length) { target = logicData.textTargets[globalParticleIndex]; } 
                    else { target = item.scatterPos; }
                } else {
                    target = item.scatterPos; 
                }
                
                if (effectiveState === STATE.SCATTER) item.currentPos.y += Math.sin(time + i)*0.005;
                const lerpSpeed = effectiveState === STATE.TEXT ? 0.1 : 0.08;
                item.currentPos.lerp(target, lerpSpeed);
                item.rotation.x += item.rotSpeed.x; item.rotation.y += item.rotSpeed.y;
                
                let s = item.scale; 
                if(currentState === STATE.ZOOM) s *= 0.5; // Zoomæ—¶èƒŒæ™¯å˜æš—æ·¡
                if(effectiveState === STATE.TEXT && globalParticleIndex >= logicData.textTargets.length) s *= 0.2; 
                
                dummy.position.copy(item.currentPos); dummy.rotation.copy(item.rotation); dummy.scale.setScalar(s); dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                globalParticleIndex++;
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        function updateDust() {
            const positions = dustSystem.geometry.attributes.position.array;
            for(let i=0; i<logicData.dust.length; i++) {
                const item = logicData.dust[i];
                let target;
                
                let effectiveState = currentState;
                if(currentState === STATE.ZOOM) effectiveState = backgroundState;

                if (effectiveState === STATE.TREE) target = item.treePos;
                else if (effectiveState === STATE.TEXT) {
                     if (globalParticleIndex < logicData.textTargets.length) target = logicData.textTargets[globalParticleIndex];
                     else target = item.scatterPos;
                } else target = item.scatterPos;

                if(effectiveState !== STATE.TREE && effectiveState !== STATE.TEXT) item.currentPos.lerp(target, 0.05);
                else if (effectiveState === STATE.TEXT) item.currentPos.lerp(target, 0.1);
                else {
                    item.currentPos.y += 0.05; if(item.currentPos.y > CONFIG.treeHeight/2) item.currentPos.y = -CONFIG.treeHeight/2;
                    const normH = (item.currentPos.y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                    const rMax = CONFIG.maxRadius * (1-normH) + 2; const rCurr = Math.sqrt(item.currentPos.x**2 + item.currentPos.z**2);
                    if(rCurr > rMax) { item.currentPos.x *= 0.98; item.currentPos.z *= 0.98; }
                }
                positions[i*3] = item.currentPos.x; positions[i*3+1] = item.currentPos.y; positions[i*3+2] = item.currentPos.z;
                globalParticleIndex++;
            }
            dustSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updatePhotos() {
            photoMeshes.forEach((mesh, idx) => {
                let targetPos, targetScale = 2.0; let targetRot = mesh.userData.baseRot;
                if (currentState === STATE.SCATTER || currentState === STATE.TEXT) { targetScale = 4.0; mesh.lookAt(camera.position); }
                
                if (currentState === STATE.ZOOM && idx === zoomTargetIndex) {
                    const targetWorldPos = new THREE.Vector3(0, 0, 80); 
                    targetPos = mainGroup.worldToLocal(targetWorldPos);
                    targetScale = 4.0; mesh.lookAt(camera.position); targetRot = mesh.rotation.clone();
                } else if (currentState === STATE.TEXT) {
                    targetPos = new THREE.Vector3((idx - photoMeshes.length/2) * 5, -30, 0); targetScale = 3.0;
                    mesh.lookAt(camera.position); targetRot = mesh.rotation.clone();
                } else {
                    targetPos = currentState === STATE.TREE ? mesh.userData.treePos : mesh.userData.scatterPos;
                    if(currentState !== STATE.TREE) mesh.position.y += Math.sin(time+idx)*0.01;
                    if (currentState === STATE.TREE) { 
                        mesh.rotation.y += 0.01; targetRot = mesh.rotation;
                    }
                }
                mesh.position.lerp(targetPos, 0.1); 
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                if(currentState !== STATE.ZOOM && currentState !== STATE.TEXT) mesh.rotation.copy(targetRot);
            });
        }

        function loadBuiltInPhotos() {
            if (myPhotos.length === 0) return;
            const loader = new THREE.TextureLoader();
            myPhotos.forEach(fileName => { 
                loader.load(fileName, 
                    function (texture) { addPhotoMesh(texture); },
                    undefined,
                    function(e){ console.warn("Photo missing:", fileName); }
                ); 
            });
        }

        function addPhotoMesh(texture) {
            texture.colorSpace = THREE.SRGBColorSpace; const img = texture.image;
            let w = 4, h = 4; if(img.width > img.height) h = 4 * (img.height/img.width); else w = 4 * (img.width/img.height);
            const geo = new THREE.PlaneGeometry(w, h); const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, color: 0xcccccc });
            const mesh = new THREE.Mesh(geo, mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, h+0.2, 0.1), new THREE.MeshPhysicalMaterial({color:0xffd700, roughness:0.2, metalness:1}));
            frame.position.z = -0.06; mesh.add(frame);
            const h_pos = (Math.random() - 0.5) * CONFIG.treeHeight;
            const normH = (h_pos + CONFIG.treeHeight/2) / CONFIG.treeHeight;
            const maxR = CONFIG.maxRadius * (1 - normH); const r = maxR * (0.3 + 0.6 * Math.sqrt(Math.random())); const theta = Math.random() * Math.PI * 2;
            const treePos = new THREE.Vector3(r * Math.cos(theta), h_pos, r * Math.sin(theta));
            mesh.userData = { treePos, scatterPos: randomSpherePoint(50), baseRot: new THREE.Euler(0, Math.random()*Math.PI, 0) };
            mesh.position.copy(treePos); photoMeshes.push(mesh); mainGroup.add(mesh);
        }

        async function setupMediaPipe() {
            try {
                let finalPath = './hand_landmarker.task';
                try {
                    const check = await fetch('./model.bin', {method:'HEAD'});
                    if(check.ok) finalPath = './model.bin';
                } catch(e) {}

                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: finalPath, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                const video = document.getElementById("input-video");
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, frameRate: { ideal: 30 } } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    document.getElementById('status-text').innerText = "ç³»ç»Ÿå°±ç»ªï¼Œè¯·ä¼¸æ‰‹";
                    aiReady = true;
                    predictWebcam(handLandmarker, video);
                });
            } catch (error) {
                console.error("AIå¯åŠ¨å¤±è´¥:", error);
                document.getElementById('status-text').innerHTML = "<span style='color:red'>AIå¯åŠ¨å¤±è´¥(æ£€æŸ¥æ–‡ä»¶)</span>";
            }
        }

        let lastVideoTime = -1; let lastPredictionTime = 0;
        async function predictWebcam(handLandmarker, video) {
            try {
                const now = performance.now();
                if (video.currentTime !== lastVideoTime && (now - lastPredictionTime > 50)) {
                    lastVideoTime = video.currentTime; lastPredictionTime = now;
                    const result = handLandmarker.detectForVideo(video, now);
                    const canvas = document.getElementById('skeleton-canvas'); const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    if (result.landmarks && result.landmarks.length > 0) {
                        const landmarks = result.landmarks[0]; isHandPresent = true;
                        drawSkeleton(ctx, landmarks, canvas.width, canvas.height); handleGesture(landmarks);
                    } else { 
                        isHandPresent = false; 
                        // === æ‰‹åŠ¿æ¶ˆå¤±ï¼Œè‡ªåŠ¨å½’ä½ä¸ºæ ‘ï¼ˆä½†Zoomæ—¶ä¸å½’ä½ï¼‰ ===
                        if (currentState !== STATE.ZOOM && currentState !== STATE.TREE) {
                            currentState = STATE.TREE;
                            document.getElementById('status-text').innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>è‡ªåŠ¨å½’ä½ (åœ£è¯æ ‘)</span>";
                        }
                    }
                }
            } catch(e) { console.warn("Frame Error:", e); }
            requestAnimationFrame(() => predictWebcam(handLandmarker, video));
        }
        
        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.lineWidth = 2; ctx.strokeStyle = '#00ff88'; ctx.fillStyle = '#ff0044';
            const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            ctx.beginPath();
            for (let i = 0; i < connections.length; i++) {
                const start = landmarks[connections[i][0]], end = landmarks[connections[i][1]];
                ctx.moveTo(start.x * w, start.y * h); ctx.lineTo(end.x * w, end.y * h);
            }
            ctx.stroke(); for(let i=0; i<landmarks.length; i++) { ctx.beginPath(); ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 3, 0, 2 * Math.PI); ctx.fill(); }
        }

        // === æœ€ç»ˆä¿®æ­£æ‰‹åŠ¿ ===
        function handleGesture(landmarks) {
            const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2; const palmY = (landmarks[0].y + landmarks[9].y) / 2;
            handPos.x = handPos.x * 0.8 + palmX * 0.2; handPos.y = handPos.y * 0.8 + palmY * 0.2;

            // 1. æåˆ: ææ˜“è§¦å‘
            const dPinch = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
            const isPinch = dPinch < 0.12; 

            // 2. æ¡æ‹³
            let folded = [false, false, false, false]; 
            const fingerTips = [8, 12, 16, 20];
            fingerTips.forEach((tipIdx, i) => {
                const d = Math.sqrt(Math.pow(landmarks[tipIdx].x - landmarks[0].x, 2) + Math.pow(landmarks[tipIdx].y - landmarks[0].y, 2));
                if (d < 0.35) folded[i] = true;
            });
            const isFist = folded.filter(f=>f).length >= 4;

            // 3. æ¯”è€¶
            const isPeace = !folded[0] && !folded[1] && folded[2] && folded[3];

            // 4. å¼ å¼€
            const isOpen = folded.filter(f=>f).length <= 1; 

            const status = document.getElementById('status-text');

            // === çŠ¶æ€æœºé€»è¾‘ ===

            // A. å¦‚æœåœ¨ ZOOM çŠ¶æ€ï¼šå¿…é¡»å¼ æ‰‹æ‰èƒ½é€€å‡º
            if (currentState === STATE.ZOOM) {
                if (isOpen) {
                    currentState = backgroundState; // å›åˆ°ä¹‹å‰çš„çŠ¶æ€ï¼ˆæ ‘æˆ–æ•£å¼€ï¼‰
                    zoomTargetIndex = -1;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>é€€å‡ºæŸ¥çœ‹ (èƒŒæ™¯æ¢å¤)</span>";
                } else {
                    // æ— è®ºä½ æ‰‹æ€ä¹ˆåŠ¨ï¼Œåªè¦ä¸å¼ å¼€ï¼Œå°±ä¿æŒ ZOOM
                    status.innerHTML = "çŠ¶æ€: <span style='color:#ffd700'>æŸ¥çœ‹è¯¦æƒ… (å¼ æ‰‹å…³é—­)</span>";
                }
                return; // é”å®šçŠ¶æ€ï¼Œä¸æ‰§è¡Œåç»­é€»è¾‘
            }

            // B. å¦‚æœæ²¡åœ¨ ZOOMï¼Œæ£€æµ‹æåˆè¿›å…¥ ZOOM
            if (isPinch) {
                if (photoMeshes.length > 0) {
                    backgroundState = currentState; // è®°ä½å½“å‰èƒŒæ™¯æ˜¯å•¥
                    currentState = STATE.ZOOM;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#ffd700'>å·²é”å®š (æ¾æ‰‹ä¸æ‰)</span>";
                    
                    // æ‰¾æœ€è¿‘çš„ç…§ç‰‡
                    let minDist = Infinity; let bestIdx = 0; const camPos = camera.position; const worldPos = new THREE.Vector3();
                    photoMeshes.forEach((mesh, idx) => {
                        mesh.getWorldPosition(worldPos); if (worldPos.distanceTo(camPos) < minDist) { minDist = worldPos.distanceTo(camPos); bestIdx = idx; }
                    });
                    zoomTargetIndex = bestIdx;
                }
                return;
            }

            // C. å…¶ä»–æ‰‹åŠ¿
            if (isPeace) {
                if(currentState !== STATE.TEXT) {
                    currentState = STATE.TEXT; zoomTargetIndex = -1;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#ff69b4'>åœ£è¯ç¥ç¦æ±‡èš!</span>";
                }
            } else if (isFist) {
                currentState = STATE.TREE; zoomTargetIndex = -1; rotationVelocity.x = 0; rotationVelocity.y = 0;
                status.innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>èšåˆåœ£è¯æ ‘</span>";
            } else if (isOpen) {
                if(currentState !== STATE.SCATTER) {
                    currentState = STATE.SCATTER; zoomTargetIndex = -1;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>æ˜Ÿäº‘æ•£å¼€</span>";
                }
            } else {
                // é»˜è®¤çŠ¶æ€ä¸‹å¦‚æœæ‰‹è¿˜åœ¨ï¼Œä¿æŒå½“å‰çŠ¶æ€ï¼Œä¸å¼ºåˆ¶å½’ä½
                // åªæœ‰æ‰‹å½»åº•æ¶ˆå¤±ï¼ŒpredictWebcamé‡Œæ‰ä¼šå¼ºåˆ¶å½’ä½
            }
        }

        function onWindowResize() {
            const dims = updateDimensions();
            camera.aspect = dims.width / dims.height; camera.updateProjectionMatrix();
            renderer.setSize(dims.width, dims.height); composer.setSize(dims.width, dims.height);
            composer.passes[1].resolution.set(dims.width, dims.height);
        }

        initThree();
    </script>
</body>
</html>