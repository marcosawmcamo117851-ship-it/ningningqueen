<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å®å®å¤§ç‹ - Merry Christmas</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">

    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'ZCOOL KuaiLe', sans-serif; 
            display: flex; justify-content: center; align-items: center; height: 100vh;
            touch-action: none; 
        }
        #canvas-wrapper { position: relative; background: #000; height: 100vh; width: 100vw; }
        #canvas-container { width: 100%; height: 100%; display: block; }
        
        /* é»˜è®¤æ ·å¼ */
        #video-container {
            position: absolute; top: 20px; right: 20px; width: 100px; height: 75px; z-index: 2;
            border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); background: rgba(0,0,0,0.5); opacity: 0.8;
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        
        #title-layer {
            position: absolute; top: 8%; left: 0; width: 100%; display: flex; justify-content: center;
            z-index: 4; pointer-events: none; text-align: center;
        }
        h1 {
            font-family: 'ZCOOL KuaiLe', sans-serif; font-weight: 400; letter-spacing: 2px; font-size: 1.8rem; margin: 0;
            background: linear-gradient(to bottom, #fff 30%, #ffd700 90%); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); /* å‡å°‘é˜´å½±è®¡ç®— */
            width: 100%;
        }

        #ui-layer { position: absolute; bottom: 30px; left: 5%; width: 90%; z-index: 3; pointer-events: none; color: #fff; }
        .instructions {
            font-size: 0.8rem; color: #ccc; line-height: 1.6;
            background: rgba(0, 0, 0, 0.4); padding: 10px; border-radius: 8px;
            border-left: 3px solid #ffd700;
        }
        .highlight { color: #ffd700; font-weight: bold; }
        #status-text { margin-bottom: 8px; font-size: 1.1rem; color: #fff; font-weight: bold; }
        
        #fullscreen-btn {
            position: absolute; top: 20px; right: 130px; z-index: 20;
            background: rgba(0,0,0,0.3); color: #ffd700; border: 1px solid #ffd700;
            width: 36px; height: 36px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 1.1rem;
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>
    <audio id="bgm" loop><source src="music.mp3" type="audio/mp3"></audio>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
        <div id="title-layer"><h1>å®å®å¤§ç‹ Merry Christmas</h1></div>
        
        <div id="video-container">
            <video id="input-video" autoplay playsinline muted></video>
            <canvas id="skeleton-canvas"></canvas>
        </div>
        
        <button id="fullscreen-btn" onclick="toggleUI()">â›¶</button>

        <div id="ui-layer">
            <div id="status-text">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>
            <div class="instructions">
                â€¢ <span class="highlight">æ¡æ‹³/è‡ªç„¶</span> : åœ£è¯æ ‘<br/>
                â€¢ <span class="highlight">å¼ å¼€æ‰‹</span> : æ˜Ÿäº‘æ•£å¼€<br/>
                â€¢ <span class="highlight">æ¯”è€¶(âœŒï¸)</span> : å˜æˆæ–‡å­—<br/>
                â€¢ <span class="highlight">æåˆ(ğŸ‘Œ)</span> : é”å®šç…§ç‰‡
            </div>
        </div>
    </div>

    <canvas id="textCanvas" width="1024" height="256" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        // ç§»é™¤äº† EffectComposer (Bloomç‰¹æ•ˆ)ï¼Œç›´æ¥æ¸²æŸ“ï¼Œæ€§èƒ½æå‡å·¨å¤§
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        const myPhotos = ['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg', '9.jpg', '10.jpg', '11.jpg', '12.jpg', '13.jpg', '14.jpg', '15.jpg', '16.jpg', '17.jpg', '18.jpg', '19.jpg', '20.jpg', '21.jpg', '22.jpg', '23.jpg', '24.jpg', '25.jpg', '26.jpg', '27.jpg'];

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // === ğŸš€ æé€Ÿç‰ˆé…ç½®ï¼šå¤§å¹…å‡å°‘ç²’å­æ•°é‡ ===
        const CONFIG = {
            goldCount: 60, silverCount: 60, gemCount: 40, emeraldCount: 40, // æ•°é‡å‡åŠå†å‡åŠ
            dustCount: 150, // å°˜åŸƒå‡å°‘
            treeHeight: 75, maxRadius: 30
        };

        const STATE = { TREE: 'tree', SCATTER: 'scatter', ZOOM: 'zoom', TEXT: 'text' };
        let currentState = STATE.TREE;
        let backgroundState = STATE.TREE; 
        
        let scene, camera, renderer, mainGroup = new THREE.Group();
        let goldMesh, silverMesh, gemMesh, emeraldMesh, dustSystem;
        let photoMeshes = [];
        let zoomTargetIndex = -1;
        let logicData = { gold: [], silver: [], gem: [], emerald: [], dust: [], textTargets: [] };
        const dummy = new THREE.Object3D();
        let time = 0;
        
        let handPos = { x: 0, y: 0 };
        let lastHandPos = { x: 0, y: 0 };
        let isHandPresent = false;
        let rotationVelocity = { x: 0, y: 0 };
        let aiReady = false;

        window.toggleUI = function() { document.getElementById('canvas-wrapper').classList.toggle('hide-ui'); };

        function initMusic() {
            const audio = document.getElementById('bgm');
            const playAudio = () => { if(audio.paused) audio.play().catch(e => {}); };
            document.body.addEventListener('click', playAudio, { once: true });
            document.body.addEventListener('touchstart', playAudio, { once: true });
        }

        function generateTextTargets(font = 'Arial') {
            try {
                const canvas = document.getElementById('textCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `bold 130px "${font}", "SimHei", sans-serif`;
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('å®å®å¤§ç‹åœ£è¯å¿«ä¹', canvas.width / 2, canvas.height / 2);
                const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                logicData.textTargets = [];
                const step = 7; // è¿›ä¸€æ­¥åŠ å¤§é‡‡æ ·æ­¥é•¿ï¼Œå‡å°‘æ–‡å­—ç²’å­
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        if (data[(y * canvas.width + x) * 4 + 3] > 128) {
                            logicData.textTargets.push(new THREE.Vector3((x - canvas.width / 2) * 0.12, -(y - canvas.height / 2) * 0.12 + 5, 0));
                        }
                    }
                }
                logicData.textTargets.sort(() => Math.random() - 0.5);
            } catch(e) {}
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            const wrapper = document.getElementById('canvas-wrapper');
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯
            
            updateDimensions();
            camera = new THREE.PerspectiveCamera(50, wrapper.clientWidth / wrapper.clientHeight, 0.1, 1000);
            
            if (isMobile) camera.position.set(0, 0, 140);
            else camera.position.set(0, 0, 110);

            // ğŸš€ æ€§èƒ½ä¼˜åŒ–æ ¸å¿ƒï¼šå–æ¶ˆæŠ—é”¯é½¿ï¼Œé™åˆ¶åˆ†è¾¨ç‡ä¸º 1.0 (ä¸ä½¿ç”¨é«˜æ¸…æ¸²æŸ“)
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
            renderer.setPixelRatio(1); // å¼ºåˆ¶ 1 å€åˆ†è¾¨ç‡ï¼Œæ‰‹æœºæ•‘æ˜Ÿ
            container.appendChild(renderer.domElement);
            
            // ç®€å•çš„ç¯å¢ƒå…‰ï¼Œç§»é™¤å¤æ‚çš„ Environment
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffddaa, 2);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            
            // ç§»é™¤äº† Bloom Passï¼Œç›´æ¥æ¸²æŸ“åœºæ™¯

            createMaterialsAndMeshes(); createDust(); createStarField(); loadBuiltInPhotos();
            scene.add(mainGroup);

            window.addEventListener('resize', onWindowResize);
            initMusic();
            generateTextTargets('ZCOOL KuaiLe'); 
            document.fonts.load('130px "ZCOOL KuaiLe"').then(() => generateTextTargets('ZCOOL KuaiLe')).catch(()=>{});

            animate();
            document.getElementById('status-text').innerText = "ç”»é¢å°±ç»ªï¼Œæ­£åœ¨è¿æ¥æ‘„åƒå¤´...";
            setupMediaPipe();
        }

        function updateDimensions() {
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = '100vw';
            wrapper.style.height = '100vh';
            return { width: window.innerWidth, height: window.innerHeight };
        }

        function createMaterialsAndMeshes() {
            // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæè´¨é™çº§
            // ä½¿ç”¨ MeshLambertMaterial ä»£æ›¿ MeshPhysicalMaterial
            // è¿™æ˜¯ä¸€ä¸ªå·¨å¤§çš„æ€§èƒ½æå‡ï¼Œè™½ç„¶ä¸é‚£ä¹ˆé—ªäº®ï¼Œä½†éå¸¸å¿«
            const goldMat = new THREE.MeshLambertMaterial({ color: 0xffaa00 });
            const silverMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const gemMat = new THREE.MeshLambertMaterial({ color: 0xff0044 });
            const emeraldMat = new THREE.MeshLambertMaterial({ color: 0x00aa55 });

            goldMesh = createInstancedMesh(new THREE.SphereGeometry(0.7, 6, 6), goldMat, CONFIG.goldCount, logicData.gold);
            silverMesh = createInstancedMesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), silverMat, CONFIG.silverCount, logicData.silver);
            gemMesh = createInstancedMesh(new THREE.OctahedronGeometry(0.8, 0), gemMat, CONFIG.gemCount, logicData.gem);
            emeraldMesh = createInstancedMesh(new THREE.ConeGeometry(0.5, 1.2, 5), emeraldMat, CONFIG.emeraldCount, logicData.emerald);

            const star = new THREE.Mesh(new THREE.OctahedronGeometry(3.0, 0), new THREE.MeshBasicMaterial({ color: 0xffffaa })); // ç®€å•çš„è‡ªå‘å…‰
            star.userData = { treePos: new THREE.Vector3(0, CONFIG.treeHeight/2 + 2, 0), scatterPos: new THREE.Vector3(0, 60, 0) };
            star.position.copy(star.userData.treePos); mainGroup.add(star); logicData.star = star;
        }

        function createInstancedMesh(geo, mat, count, dataArray) {
            const mesh = new THREE.InstancedMesh(geo, mat, count); mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); mainGroup.add(mesh);
            generateLogicData(count, dataArray); return mesh;
        }

        function generateLogicData(count, array) {
            for (let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const normH = (h + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                const rMax = CONFIG.maxRadius * (1 - normH); const r = Math.sqrt(Math.random()) * rMax; const theta = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));
                array.push({
                    treePos: treePos, scatterPos: randomSpherePoint(40 + Math.random()*40), currentPos: treePos.clone(),
                    scale: 0.6 + Math.random() * 0.8, rotSpeed: new THREE.Euler(Math.random()*0.03, Math.random()*0.03, Math.random()*0.03), rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0)
                });
            }
        }

        function randomSpherePoint(r) {
            const u = Math.random(), v = Math.random(); const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }

        function createDust() {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for(let i=0; i<CONFIG.dustCount; i++) {
                const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const r = Math.random() * CONFIG.maxRadius * (1 - (h + CONFIG.treeHeight/2)/CONFIG.treeHeight) + 2; 
                const theta = Math.random() * Math.PI * 2; pos.push(r*Math.cos(theta), h, r*Math.sin(theta));
                logicData.dust.push({ treePos: new THREE.Vector3(r*Math.cos(theta), h, r*Math.sin(theta)), scatterPos: randomSpherePoint(60), currentPos: new THREE.Vector3(r*Math.cos(theta), h, r*Math.sin(theta)) });
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            // ä½¿ç”¨ç®€å•çš„ç‚¹æè´¨
            dustSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.4 }));
            mainGroup.add(dustSystem);
        }
        
        function createStarField() {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for(let i=0; i<600; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color: 0x888888, size: 1.0, transparent: true, opacity: 0.3})));
        }

        let globalParticleIndex = 0;
        function animate() {
            requestAnimationFrame(animate); time += 0.01; globalParticleIndex = 0;
            
            if(goldMesh) updateInstancedMesh(goldMesh, logicData.gold); 
            if(silverMesh) updateInstancedMesh(silverMesh, logicData.silver);
            if(gemMesh) updateInstancedMesh(gemMesh, logicData.gem); 
            if(emeraldMesh) updateInstancedMesh(emeraldMesh, logicData.emerald);
            if(dustSystem) updateDust(); 
            updatePhotos();
            
            if (logicData.star) {
                let target;
                let effectiveState = currentState;
                if(currentState === STATE.ZOOM) effectiveState = backgroundState;

                if (effectiveState === STATE.TREE) target = logicData.star.userData.treePos;
                else if (effectiveState === STATE.TEXT) target = new THREE.Vector3(0, 20, 0);
                else target = logicData.star.userData.scatterPos;
                
                logicData.star.position.lerp(target, 0.05); logicData.star.rotation.y += 0.01;
            }

            if (currentState === STATE.ZOOM) { 
                rotationVelocity.x *= 0.95; rotationVelocity.y *= 0.95;
                mainGroup.rotation.y += rotationVelocity.y;
            } else if (currentState === STATE.TEXT) { 
                rotationVelocity.x = 0; rotationVelocity.y = 0;
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 0.05);
                mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, 0, 0.05);
            } else if (currentState === STATE.SCATTER) {
                if (isHandPresent && aiReady) {
                    const deltaX = handPos.x - lastHandPos.x; 
                    if (Math.abs(deltaX) > 0.001) rotationVelocity.y += deltaX * 0.15; 
                    lastHandPos.x = handPos.x; lastHandPos.y = handPos.y;
                }
                rotationVelocity.y *= 0.99; 
                mainGroup.rotation.y += rotationVelocity.y; 
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 0.1);
            } else if (currentState === STATE.TREE) { 
                mainGroup.rotation.y += 0.003; 
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 0.05);
            }
            
            // ğŸš€ ç›´æ¥æ¸²æŸ“ï¼Œä¸ç»è¿‡åæœŸå¤„ç†ï¼Œæå¤§æå‡ FPS
            renderer.render(scene, camera);
        }

        function updateInstancedMesh(mesh, dataArray) {
            for (let i = 0; i < dataArray.length; i++) {
                const item = dataArray[i];
                let target;
                
                let effectiveState = currentState;
                if(currentState === STATE.ZOOM) effectiveState = backgroundState;

                if (effectiveState === STATE.TREE) target = item.treePos;
                else if (effectiveState === STATE.TEXT) {
                    if (globalParticleIndex < logicData.textTargets.length) { target = logicData.textTargets[globalParticleIndex]; } 
                    else { target = item.scatterPos; }
                } else {
                    target = item.scatterPos; 
                }
                
                if (effectiveState === STATE.SCATTER) item.currentPos.y += Math.sin(time + i)*0.005;
                const lerpSpeed = effectiveState === STATE.TEXT ? 0.1 : 0.08;
                item.currentPos.lerp(target, lerpSpeed);
                item.rotation.x += item.rotSpeed.x; item.rotation.y += item.rotSpeed.y;
                let s = item.scale; 
                if(currentState === STATE.ZOOM) s *= 0.5; 
                if(effectiveState === STATE.TEXT && globalParticleIndex >= logicData.textTargets.length) s *= 0.2; 
                dummy.position.copy(item.currentPos); dummy.rotation.copy(item.rotation); dummy.scale.setScalar(s); dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                globalParticleIndex++;
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        function updateDust() {
            const positions = dustSystem.geometry.attributes.position.array;
            for(let i=0; i<logicData.dust.length; i++) {
                const item = logicData.dust[i];
                let target;
                let effectiveState = currentState;
                if(currentState === STATE.ZOOM) effectiveState = backgroundState;

                if (effectiveState === STATE.TREE) target = item.treePos;
                else if (effectiveState === STATE.TEXT) {
                     if (globalParticleIndex < logicData.textTargets.length) target = logicData.textTargets[globalParticleIndex];
                     else target = item.scatterPos;
                } else target = item.scatterPos;

                if(effectiveState !== STATE.TREE && effectiveState !== STATE.TEXT) item.currentPos.lerp(target, 0.05);
                else if (effectiveState === STATE.TEXT) item.currentPos.lerp(target, 0.1);
                else {
                    item.currentPos.y += 0.05; if(item.currentPos.y > CONFIG.treeHeight/2) item.currentPos.y = -CONFIG.treeHeight/2;
                    const normH = (item.currentPos.y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                    const rMax = CONFIG.maxRadius * (1-normH) + 2; const rCurr = Math.sqrt(item.currentPos.x**2 + item.currentPos.z**2);
                    if(rCurr > rMax) { item.currentPos.x *= 0.98; item.currentPos.z *= 0.98; }
                }
                positions[i*3] = item.currentPos.x; positions[i*3+1] = item.currentPos.y; positions[i*3+2] = item.currentPos.z;
                globalParticleIndex++;
            }
            dustSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updatePhotos() {
            photoMeshes.forEach((mesh, idx) => {
                let targetPos, targetScale = 2.0; let targetRot = mesh.userData.baseRot;
                if (currentState === STATE.SCATTER || currentState === STATE.TEXT) { targetScale = 4.0; mesh.lookAt(camera.position); }
                
                if (currentState === STATE.ZOOM && idx === zoomTargetIndex) {
                    const targetWorldPos = new THREE.Vector3(0, 0, 80); 
                    targetPos = mainGroup.worldToLocal(targetWorldPos);
                    targetScale = 4.0; mesh.lookAt(camera.position); targetRot = mesh.rotation.clone();
                } else if (currentState === STATE.TEXT) {
                    targetPos = new THREE.Vector3((idx - photoMeshes.length/2) * 5, -30, 0); targetScale = 3.0;
                    mesh.lookAt(camera.position); targetRot = mesh.rotation.clone();
                } else {
                    targetPos = currentState === STATE.TREE ? mesh.userData.treePos : mesh.userData.scatterPos;
                    if(currentState !== STATE.TREE) mesh.position.y += Math.sin(time+idx)*0.01;
                    if (currentState === STATE.TREE) { 
                        mesh.rotation.y += 0.01; targetRot = mesh.rotation;
                    }
                }
                mesh.position.lerp(targetPos, 0.1); 
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                if(currentState !== STATE.ZOOM && currentState !== STATE.TEXT) mesh.rotation.copy(targetRot);
            });
        }

        function loadBuiltInPhotos() {
            if (myPhotos.length === 0) return;
            const loader = new THREE.TextureLoader();
            myPhotos.forEach(fileName => { 
                loader.load(fileName, 
                    function (texture) { addPhotoMesh(texture); },
                    undefined,
                    function(e){ console.warn("Photo missing:", fileName); }
                ); 
            });
        }

        function addPhotoMesh(texture) {
            texture.colorSpace = THREE.SRGBColorSpace; const img = texture.image;
            let w = 4, h = 4; if(img.width > img.height) h = 4 * (img.height/img.width); else w = 4 * (img.width/img.height);
            const geo = new THREE.PlaneGeometry(w, h); const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, color: 0xcccccc });
            const mesh = new THREE.Mesh(geo, mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, h+0.2, 0.1), new THREE.MeshBasicMaterial({color:0xffd700})); // ç®€åŒ–è¾¹æ¡†æè´¨
            frame.position.z = -0.06; mesh.add(frame);
            const h_pos = (Math.random() - 0.5) * CONFIG.treeHeight;
            const normH = (h_pos + CONFIG.treeHeight/2) / CONFIG.treeHeight;
            const maxR = CONFIG.maxRadius * (1 - normH); const r = maxR * (0.3 + 0.6 * Math.sqrt(Math.random())); const theta = Math.random() * Math.PI * 2;
            const treePos = new THREE.Vector3(r * Math.cos(theta), h_pos, r * Math.sin(theta));
            mesh.userData = { treePos, scatterPos: randomSpherePoint(50), baseRot: new THREE.Euler(0, Math.random()*Math.PI, 0) };
            mesh.position.copy(treePos); photoMeshes.push(mesh); mainGroup.add(mesh);
        }

        async function setupMediaPipe() {
            try {
                let finalPath = './model.bin'; 
                try {
                    const check = await fetch('./hand_landmarker.task', {method:'HEAD'});
                    if(check.ok) finalPath = './hand_landmarker.task';
                } catch(e) {}

                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: finalPath, 
                        delegate: "GPU" 
                    },
                    runningMode: "VIDEO", numHands: 1
                });

                // å…¼å®¹æ€§æ‘„åƒå¤´è¯·æ±‚
                const video = document.getElementById("input-video");
                const constraints = {
                    video: {
                        facingMode: "user",
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    document.getElementById('status-text').innerText = "ç³»ç»Ÿå°±ç»ªï¼Œè¯·ä¼¸æ‰‹";
                    aiReady = true;
                    predictWebcam(handLandmarker, video);
                });
            } catch (error) {
                console.error("AIå¯åŠ¨å¤±è´¥:", error);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + error.name + "\nè¯·å°è¯•ç”¨ Safari æˆ– Chrome æµè§ˆå™¨æ‰“å¼€");
                document.getElementById('status-text').innerHTML = "<span style='color:red'>æ‘„åƒå¤´å¯åŠ¨å¤±è´¥(ç‚¹å‡»åˆ·æ–°)</span>";
            }
        }

        let lastVideoTime = -1; let lastPredictionTime = 0;
        async function predictWebcam(handLandmarker, video) {
            try {
                const now = performance.now();
                // ğŸš€ AI é™é¢‘åˆ° 100ms ä¸€æ¬¡ï¼Œé‡Šæ”¾ CPU
                if (video.currentTime !== lastVideoTime && (now - lastPredictionTime > 100)) {
                    lastVideoTime = video.currentTime; lastPredictionTime = now;
                    const result = handLandmarker.detectForVideo(video, now);
                    const canvas = document.getElementById('skeleton-canvas'); const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    if (result.landmarks && result.landmarks.length > 0) {
                        const landmarks = result.landmarks[0]; isHandPresent = true;
                        drawSkeleton(ctx, landmarks, canvas.width, canvas.height); handleGesture(landmarks);
                    } else { 
                        isHandPresent = false; 
                        if (currentState !== STATE.ZOOM && currentState !== STATE.TREE) {
                            currentState = STATE.TREE;
                            document.getElementById('status-text').innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>è‡ªåŠ¨å½’ä½ (åœ£è¯æ ‘)</span>";
                        }
                    }
                }
            } catch(e) { console.warn("Frame Error:", e); }
            requestAnimationFrame(() => predictWebcam(handLandmarker, video));
        }
        
        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.lineWidth = 2; ctx.strokeStyle = '#00ff88'; ctx.fillStyle = '#ff0044';
            const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            ctx.beginPath();
            for (let i = 0; i < connections.length; i++) {
                const start = landmarks[connections[i][0]], end = landmarks[connections[i][1]];
                ctx.moveTo(start.x * w, start.y * h); ctx.lineTo(end.x * w, end.y * h);
            }
            ctx.stroke(); for(let i=0; i<landmarks.length; i++) { ctx.beginPath(); ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 3, 0, 2 * Math.PI); ctx.fill(); }
        }

        function handleGesture(landmarks) {
            const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2; const palmY = (landmarks[0].y + landmarks[9].y) / 2;
            handPos.x = handPos.x * 0.8 + palmX * 0.2; handPos.y = handPos.y * 0.8 + palmY * 0.2;

            const dPinch = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
            const isPinch = dPinch < 0.12; 

            let folded = [false, false, false, false]; 
            const fingerTips = [8, 12, 16, 20];
            fingerTips.forEach((tipIdx, i) => {
                const d = Math.sqrt(Math.pow(landmarks[tipIdx].x - landmarks[0].x, 2) + Math.pow(landmarks[tipIdx].y - landmarks[0].y, 2));
                if (d < 0.35) folded[i] = true;
            });
            const isFist = folded.filter(f=>f).length >= 4;
            const isPeace = !folded[0] && !folded[1] && folded[2] && folded[3];
            const isOpen = folded.filter(f=>f).length <= 1; 

            const status = document.getElementById('status-text');

            if (currentState === STATE.ZOOM) {
                if (isOpen) {
                    currentState = backgroundState; 
                    zoomTargetIndex = -1;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>é€€å‡ºæŸ¥çœ‹</span>";
                } else {
                    status.innerHTML = "çŠ¶æ€: <span style='color:#ffd700'>æŸ¥çœ‹ç…§ç‰‡ (å¼ æ‰‹å…³é—­)</span>";
                }
                return; 
            }

            if (isPinch) {
                if (photoMeshes.length > 0) {
                    backgroundState = currentState;
                    currentState = STATE.ZOOM;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#ffd700'>å·²é”å®š (æ¾æ‰‹ä¸æ‰)</span>";
                    
                    let minDist = Infinity; let bestIdx = 0; const camPos = camera.position; const worldPos = new THREE.Vector3();
                    photoMeshes.forEach((mesh, idx) => {
                        mesh.getWorldPosition(worldPos); if (worldPos.distanceTo(camPos) < minDist) { minDist = worldPos.distanceTo(camPos); bestIdx = idx; }
                    });
                    zoomTargetIndex = bestIdx;
                }
                return;
            }

            if (isPeace) {
                if(currentState !== STATE.TEXT) {
                    currentState = STATE.TEXT; zoomTargetIndex = -1;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#ff69b4'>åœ£è¯ç¥ç¦æ±‡èš!</span>";
                }
            } else if (isFist) {
                currentState = STATE.TREE; zoomTargetIndex = -1; rotationVelocity.x = 0; rotationVelocity.y = 0;
                status.innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>èšåˆåœ£è¯æ ‘</span>";
            } else if (isOpen) {
                if(currentState !== STATE.SCATTER) {
                    currentState = STATE.SCATTER; zoomTargetIndex = -1;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>æ˜Ÿäº‘æ•£å¼€</span>";
                }
            } else {
                if (currentState !== STATE.TREE && currentState !== STATE.TEXT) {
                    currentState = STATE.TREE;
                    status.innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>è‡ªåŠ¨å½’ä½</span>";
                }
            }
        }

        function onWindowResize() {
            updateDimensions();
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            // ç§»é™¤äº† composer.setSize
        }

        initThree();
    </script>
</body>
</html>
